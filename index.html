<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Vitesse muscu (capteurs iPhone)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #0b0d10; color: #e9eef5; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 18px; }
    .row { display: grid; gap: 14px; grid-template-columns: 1fr; }
    @media (min-width: 820px) { .row { grid-template-columns: 1.15fr 0.85fr; } }
    .card {
      background: #121722; border: 1px solid #1f2a3a; border-radius: 16px;
      padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    h1 { font-size: 20px; margin: 0 0 10px; font-weight: 700; }
    h2 { font-size: 15px; margin: 0 0 10px; opacity: .9; }
    .muted { opacity: .75; font-size: 13px; line-height: 1.35; }
    .controls { display: grid; gap: 10px; grid-template-columns: 1fr; }
    .controls .grid2 { display: grid; gap: 10px; grid-template-columns: 1fr 1fr; }
    label { font-size: 13px; opacity: .85; display: block; margin-bottom: 6px; }
    input, select {
      width: 100%; box-sizing: border-box;
      background: #0e1320; color: #e9eef5;
      border: 1px solid #263249; border-radius: 12px;
      padding: 10px 12px; font-size: 14px;
      outline: none;
    }
    input:focus, select:focus { border-color: #4b8bff; }
    button {
      background: #1e6bff; border: 0; color: white;
      padding: 10px 12px; border-radius: 12px;
      font-weight: 650; cursor: pointer; font-size: 14px;
    }
    button.secondary { background: #253047; }
    button.danger { background: #c0392b; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .big {
      display: grid; gap: 10px; align-items: center;
      grid-template-columns: 1fr;
    }
    .metric {
      background: #0e1320; border: 1px solid #263249;
      border-radius: 16px; padding: 14px;
    }
    .metric .label { font-size: 12px; opacity: .75; }
    .metric .value { font-size: 44px; font-weight: 800; letter-spacing: -0.02em; }
    .metric .unit { font-size: 14px; opacity: .8; margin-left: 6px; }
    .metric.small .value { font-size: 22px; }
    .grid3 { display: grid; gap: 10px; grid-template-columns: 1fr; }
    @media (min-width: 620px) { .grid3 { grid-template-columns: 1fr 1fr 1fr; } }
    .pill {
      display: inline-flex; align-items: center; gap: 8px;
      font-size: 12px; padding: 6px 10px; border-radius: 999px;
      background: #0e1320; border: 1px solid #263249; opacity: .95;
    }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: #9aa7bd; }
    .dot.ok { background: #2ecc71; }
    .dot.warn { background: #f1c40f; }
    .dot.bad { background: #e74c3c; }

    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border-bottom: 1px solid #243048; padding: 10px 8px; text-align: left; font-size: 13px; }
    th { opacity: .75; font-weight: 650; }
    .right { text-align: right; }
    .btnRow { display: flex; gap: 10px; flex-wrap: wrap; }
    a.link { color: #7fb0ff; }
    code { background: #0e1320; padding: 2px 6px; border-radius: 8px; border: 1px solid #263249; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Vitesse Muscu (iPhone / iPad) — mesure via capteurs</h1>
    <p class="muted">
      Fixe le téléphone solidement sur la charge / barre (orientation stable). Appuie sur <b>Démarrer</b>, autorise les capteurs,
      puis fais une répétition. À la fin de la rep, la page calcule et enregistre automatiquement :
      <b>vitesse moyenne</b>, <b>vitesse pic</b>, <b>accélération pic</b> (associées à la charge).
    </p>

    <div class="row">
      <div class="card">
        <h2>Mesure en direct</h2>

        <div class="btnRow" style="margin-bottom: 10px;">
          <button id="btnStart">Démarrer</button>
          <button id="btnStop" class="secondary" disabled>Stop</button>
          <span class="pill"><span id="statusDot" class="dot"></span> <span id="statusText">En attente</span></span>
          <span class="pill">Rep : <b id="repCount">0</b></span>
        </div>

        <div class="big">
          <div class="metric">
            <div class="label">Vitesse instantanée (approx.)</div>
            <div>
              <span class="value" id="vLive">0.00</span><span class="unit">m/s</span>
            </div>
          </div>

          <div class="grid3">
            <div class="metric small">
              <div class="label">Accélération “utile” (filtrée)</div>
              <div><span class="value" id="aLive">0.00</span><span class="unit">m/s²</span></div>
            </div>
            <div class="metric small">
              <div class="label">Vitesse pic (pendant rep)</div>
              <div><span class="value" id="vPeakLive">0.00</span><span class="unit">m/s</span></div>
            </div>
            <div class="metric small">
              <div class="label">État rep</div>
              <div><span class="value" id="repState">—</span></div>
            </div>
          </div>
        </div>

        <div style="margin-top: 12px;" class="muted">
          ⚠️ Cette mesure est une estimation basée sur l’accéléromètre. La précision dépend beaucoup de :
          fixation du téléphone, orientation stable, et absence de vibrations parasites.
        </div>
      </div>

      <div class="card">
        <h2>Paramètres</h2>

        <div class="controls">
          <div class="grid2">
            <div>
              <label for="loadInput">Charge (kg)</label>
              <input type="number" id="loadInput" value="20" step="2.5" min="0" />
            </div>
            <div>
              <label for="axisMode">Mode</label>
              <select id="axisMode">
                <option value="mag" selected>Magnitude (robuste)</option>
                <option value="x">Axe X</option>
                <option value="y">Axe Y</option>
                <option value="z">Axe Z</option>
              </select>
            </div>
          </div>

          <div class="grid2">
            <div>
              <label for="startThr">Seuil début rep (m/s²)</label>
              <input type="number" id="startThr" value="0.60" step="0.05" min="0" />
            </div>
            <div>
              <label for="stopThr">Seuil fin rep (m/s²)</label>
              <input type="number" id="stopThr" value="0.25" step="0.05" min="0" />
            </div>
          </div>

          <div class="grid2">
            <div>
              <label for="stopHold">Temps bas pour finir (ms)</label>
              <input type="number" id="stopHold" value="250" step="50" min="50" />
            </div>
            <div>
              <label for="decayTau">Anti-dérive vitesse (s)</label>
              <input type="number" id="decayTau" value="0.35" step="0.05" min="0.05" />
            </div>
          </div>

          <div class="btnRow">
            <button id="btnReset" class="secondary">Nouveau set (vider tableau)</button>
            <button id="btnExport" class="secondary">Exporter CSV</button>
          </div>

          <div class="muted">
            Conseil : laisse 1–2 secondes au repos après <b>Démarrer</b> pour que le filtre “gravity” se stabilise.
          </div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top: 14px;">
      <h2>Dernière répétition enregistrée</h2>
      <div class="grid3">
        <div class="metric small">
          <div class="label">Vitesse moyenne</div>
          <div><span class="value" id="vMean">—</span><span class="unit">m/s</span></div>
        </div>
        <div class="metric small">
          <div class="label">Vitesse pic</div>
          <div><span class="value" id="vPeak">—</span><span class="unit">m/s</span></div>
        </div>
        <div class="metric small">
          <div class="label">Accélération pic</div>
          <div><span class="value" id="aPeak">—</span><span class="unit">m/s²</span></div>
        </div>
      </div>

      <h2 style="margin-top: 14px;">Historique charge–vitesse</h2>
      <div class="muted">Chaque ligne = 1 rep. Tu peux changer la charge avant la rep suivante.</div>

      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Charge (kg)</th>
            <th class="right">Vitesse moy (m/s)</th>
            <th class="right">Vitesse pic (m/s)</th>
            <th class="right">Acc. pic (m/s²)</th>
            <th class="right">Durée (s)</th>
            <th>Horodatage</th>
          </tr>
        </thead>
        <tbody id="resultsTable"></tbody>
      </table>
    </div>

    <p class="muted" style="margin-top: 12px;">
      Astuce iPhone : <b>Partager → Ajouter à l’écran d’accueil</b> (ça fait une “app” et c’est plus stable).
    </p>
  </div>

<script>
(() => {
  // UI
  const $ = (id) => document.getElementById(id);

  const btnStart = $("btnStart");
  const btnStop  = $("btnStop");
  const btnReset = $("btnReset");
  const btnExport = $("btnExport");

  const statusDot = $("statusDot");
  const statusText = $("statusText");

  const vLiveEl = $("vLive");
  const aLiveEl = $("aLive");
  const vPeakLiveEl = $("vPeakLive");
  const repStateEl = $("repState");
  const repCountEl = $("repCount");

  const vMeanEl = $("vMean");
  const vPeakEl = $("vPeak");
  const aPeakEl = $("aPeak");

  const loadInput = $("loadInput");
  const axisMode = $("axisMode");
  const startThrEl = $("startThr");
  const stopThrEl = $("stopThr");
  const stopHoldEl = $("stopHold");
  const decayTauEl = $("decayTau");
  const tableBody = $("resultsTable");

  // Data / state
  let listening = false;
  let lastT = null;

  // Filters / signals
  let gSlow = 9.81;     // baseline (gravity-ish), updated by slow EMA
  let aEMA  = 0;        // fast EMA of motion magnitude
  let v     = 0;        // scalar speed estimate
  let vPeakLive = 0;

  // Rep detection
  let inRep = false;
  let belowSince = null;
  let repCount = 0;
  let repStartT = null;
  let repV = [];
  let repA = [];

  // Stored history
  const rows = []; // {rep, load, vMean, vPeak, aPeak, dur, iso}

  function setStatus(kind, text) {
    statusDot.className = "dot " + (kind || "");
    statusText.textContent = text;
  }

  function clampDt(dt) {
    if (!isFinite(dt) || dt <= 0) return 0.016;
    return Math.max(0.002, Math.min(0.08, dt)); // clamp between ~12Hz and 500Hz
  }

  function getParams() {
    const START_THR = parseFloat(startThrEl.value) || 0.6;
    const STOP_THR  = parseFloat(stopThrEl.value)  || 0.25;
    const STOP_HOLD_MS = parseInt(stopHoldEl.value, 10) || 250;
    const DECAY_TAU = parseFloat(decayTauEl.value) || 0.35;
    return { START_THR, STOP_THR, STOP_HOLD_MS, DECAY_TAU };
  }

  function readAccel(evt) {
    // Prefer "acceleration" (without gravity) if available; fallback to includingGravity.
    const a = evt.acceleration;
    const ag = evt.accelerationIncludingGravity;

    // Some devices give nulls. Fallback carefully.
    let ax = null, ay = null, az = null;

    if (a && (a.x !== null || a.y !== null || a.z !== null)) {
      ax = a.x; ay = a.y; az = a.z;
    } else if (ag && (ag.x !== null || ag.y !== null || ag.z !== null)) {
      ax = ag.x; ay = ag.y; az = ag.z;
    } else {
      return null;
    }

    // If still null, bail.
    if (ax === null || ay === null || az === null) return null;

    const mode = axisMode.value;
    let raw;
    if (mode === "mag") {
      raw = Math.sqrt(ax*ax + ay*ay + az*az);
    } else if (mode === "x") {
      raw = ax;
    } else if (mode === "y") {
      raw = ay;
    } else {
      raw = az;
    }

    return { raw };
  }

  function startRep(now) {
    inRep = true;
    repCount += 1;
    repCountEl.textContent = repCount.toString();
    repStateEl.textContent = "EN REP";
    repStartT = now;
    belowSince = null;
    repV = [];
    repA = [];
    v = 0;
    vPeakLive = 0;
    vPeakLiveEl.textContent = "0.00";
    setStatus("warn", "Répétition détectée");
  }

  function endRep(now) {
    inRep = false;
    repStateEl.textContent = "—";
    setStatus("ok", "En écoute");
    belowSince = null;

    if (repV.length < 6) {
      // Rep too short / noise
      repV = []; repA = [];
      v = 0; aEMA = 0;
      return;
    }

    const vMean = repV.reduce((s,x) => s + x, 0) / repV.length;
    const vPeak = Math.max(...repV);
    const aPeak = Math.max(...repA);
    const dur = (now - repStartT) / 1000;

    vMeanEl.textContent = vMean.toFixed(2);
    vPeakEl.textContent = vPeak.toFixed(2);
    aPeakEl.textContent = aPeak.toFixed(2);

    const load = parseFloat(loadInput.value) || 0;
    const iso = new Date().toISOString();

    const rowObj = { rep: repCount, load, vMean, vPeak, aPeak, dur, iso };
    rows.push(rowObj);
    renderTable();

    // reset for next rep
    repV = []; repA = [];
    v = 0; aEMA = 0;
  }

  function renderTable() {
    tableBody.innerHTML = "";
    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${r.rep}</td>
        <td>${r.load.toFixed(1)}</td>
        <td class="right">${r.vMean.toFixed(2)}</td>
        <td class="right">${r.vPeak.toFixed(2)}</td>
        <td class="right">${r.aPeak.toFixed(2)}</td>
        <td class="right">${r.dur.toFixed(2)}</td>
        <td>${r.iso.replace("T"," ").replace("Z","")}</td>
      `;
      tableBody.appendChild(tr);
    }
  }

  function exportCSV() {
    if (!rows.length) return;

    const header = ["rep","load_kg","v_mean_ms","v_peak_ms","a_peak_ms2","duration_s","timestamp_iso"];
    const lines = [header.join(",")];
    for (const r of rows) {
      lines.push([
        r.rep,
        r.load.toFixed(2),
        r.vMean.toFixed(4),
        r.vPeak.toFixed(4),
        r.aPeak.toFixed(4),
        r.dur.toFixed(4),
        r.iso
      ].join(","));
    }

    const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = `vitesse-muscu_${new Date().toISOString().slice(0,19).replace(/[:T]/g,"-")}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function resetAll() {
    rows.length = 0;
    renderTable();
    repCount = 0;
    repCountEl.textContent = "0";
    vMeanEl.textContent = "—";
    vPeakEl.textContent = "—";
    aPeakEl.textContent = "—";
  }

  function onMotion(evt) {
    const now = performance.now();
    if (lastT === null) lastT = now;
    const dt = clampDt((now - lastT) / 1000);
    lastT = now;

    const p = getParams();
    const acc = readAccel(evt);
    if (!acc) return;

    // High-pass: remove slow baseline (gravity-ish) with a slow EMA.
    const ALPHA_SLOW = 0.02;   // baseline (gravity) tracking
    const ALPHA_FAST = 0.35;   // motion smoothing (fast EMA)

    // Update baseline
    gSlow = (1 - ALPHA_SLOW) * gSlow + ALPHA_SLOW * acc.raw;

    // High-pass component
    const aHP = acc.raw - gSlow;
    const aAbs = Math.abs(aHP);

    // Fast smoothing of motion
    aEMA = (1 - ALPHA_FAST) * aEMA + ALPHA_FAST * aAbs;

    // Speed integration + anti-drift decay
    const tau = Math.max(0.05, p.DECAY_TAU);
    const decay = Math.exp(-dt / tau);
    v = v * decay + aEMA * dt;
    if (v < 0) v = 0;

    // Live displays
    aLiveEl.textContent = aEMA.toFixed(2);
    vLiveEl.textContent = v.toFixed(2);

    if (inRep) {
      repV.push(v);
      repA.push(aEMA);
      if (v > vPeakLive) {
        vPeakLive = v;
        vPeakLiveEl.textContent = vPeakLive.toFixed(2);
      }

      // Stop logic
      if (aEMA < p.STOP_THR) {
        if (belowSince === null) belowSince = now;
        if ((now - belowSince) > p.STOP_HOLD_MS) {
          endRep(now);
        }
      } else {
        belowSince = null;
      }
    } else {
      // Start logic
      if (aEMA > p.START_THR) {
        startRep(now);
      }
    }
  }

  async function requestPermissionIfNeeded() {
    // iOS 13+ requires explicit user permission via user gesture
    if (typeof DeviceMotionEvent !== "undefined" &&
        typeof DeviceMotionEvent.requestPermission === "function") {
      const resp = await DeviceMotionEvent.requestPermission();
      if (resp !== "granted") throw new Error("Permission capteurs refusée");
    }
  }

  function startListening() {
    if (listening) return;

    window.addEventListener("devicemotion", onMotion, { passive: true });
    listening = true;

    btnStart.disabled = true;
    btnStop.disabled = false;

    setStatus("ok", "En écoute");
    repStateEl.textContent = "—";

    // Reset integrators
    lastT = null;
    aEMA = 0;
    v = 0;
    vPeakLive = 0;
    vLiveEl.textContent = "0.00";
    aLiveEl.textContent = "0.00";
    vPeakLiveEl.textContent = "0.00";
  }

  function stopListening() {
    if (!listening) return;

    window.removeEventListener("devicemotion", onMotion);
    listening = false;

    btnStart.disabled = false;
    btnStop.disabled = true;

    setStatus("", "En attente");
    repStateEl.textContent = "—";

    // Reset rep state
    inRep = false;
    belowSince = null;
    repV = []; repA = [];
    v = 0; aEMA = 0; lastT = null;

    vLiveEl.textContent = "0.00";
    aLiveEl.textContent = "0.00";
    vPeakLiveEl.textContent = "0.00";
  }

  btnStart.addEventListener("click", async () => {
    try {
      setStatus("warn", "Demande d’autorisation…");
      await requestPermissionIfNeeded();
      startListening();
    } catch (e) {
      console.error(e);
      setStatus("bad", "Capteurs non autorisés / indisponibles");
      alert("Impossible d'accéder aux capteurs. Sur iPhone : Safari + HTTPS + autoriser Mouvement & Orientation.");
    }
  });

  btnStop.addEventListener("click", () => stopListening());
  btnReset.addEventListener("click", () => resetAll());
  btnExport.addEventListener("click", () => exportCSV());

  // Default status
  setStatus("", "En attente");
})();
</script>
</body>
</html>
